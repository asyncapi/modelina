{
    "adapting-input-and-output": {
        "description": "# Adapting input and output\nThis example shows how you can customize the inputs and the hook into the rendering to allow full control over what is rendered.\n\nIt takes focus on providing custom entry in JSON Schema to provide a custom type for a property.\n\n",
        "displayName": "adapting-input-and-output",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\n\n/**\n * This example shows how you can modify inputs as well as outputs to make it fit your need!\n *\n * Related issue triggering the example: https://github.com/asyncapi/modelina/issues/615\n */\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'Address',\n  type: 'object',\n  properties: {\n    dictionaryProp: {\n      'x-custom-type': 'dictionary',\n      'x-custom-dictionary-key': 'string',\n      'x-custom-dictionary-value': 'object',\n      additionalProperties: true\n    }\n  },\n  additionalProperties: false\n};\n\nconst generator = new CSharpGenerator({\n  presets: [\n    {\n      class: {\n        property: ({ property, content }) => {\n          if (\n            property.property.originalInput['x-custom-type'] === 'dictionary'\n          ) {\n            const dictKey =\n              property.property.originalInput['x-custom-dictionary-key'];\n            const dictValue =\n              property.property.originalInput['x-custom-dictionary-value'];\n            //NOTICE: I use public visibility here, so for simplicity no need to add getter/setters\n            return `public Dictionary<${dictKey}, ${dictValue}> ${property.propertyName};`;\n          }\n          return content;\n        },\n        accessor: ({ property, content }) => {\n          //NOTICE: Disabling accessor factory for specific property type\n          if (\n            property.property.originalInput['x-custom-type'] === 'dictionary'\n          ) {\n            return '';\n          }\n          return content;\n        }\n      }\n    }\n  ]\n});\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Address\n{\n  public Dictionary<string, object> dictionaryProp;\n}",
        "language": "typescript"
    },
    "asyncapi-from-object": {
        "description": "# AsyncAPI from object\n\nA basic example of how to use Modelina with a basic AsyncAPI JS object.\n\n",
        "displayName": "asyncapi-from-object",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst AsyncAPIDocument = {\n  asyncapi: '2.2.0',\n  info: {\n    title: 'example',\n    version: '0.1.0'\n  },\n  channels: {\n    '/test': {\n      subscribe: {\n        message: {\n          payload: {\n            $schema: 'http://json-schema.org/draft-07/schema#',\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              email: {\n                type: 'string',\n                format: 'email'\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(AsyncAPIDocument);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class AnonymousSchema_1 {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "asyncapi-from-parser": {
        "description": "# AsyncAPI from parser\n\nA basic example of how to use Modelina with an AsyncAPI instance from the AsyncAPI parser.\n\n",
        "displayName": "asyncapi-from-parser",
        "code": "import { Parser } from '@asyncapi/parser';\nimport { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst AsyncAPIDocument = {\n  asyncapi: '2.2.0',\n  info: {\n    title: 'example',\n    version: '0.1.0'\n  },\n  channels: {\n    '/test': {\n      subscribe: {\n        message: {\n          payload: {\n            $schema: 'http://json-schema.org/draft-07/schema#',\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              email: {\n                type: 'string',\n                format: 'email'\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const parser = new Parser();\n  const { document } = await parser.parse(JSON.stringify(AsyncAPIDocument));\n  const models = await generator.generate(document);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class AnonymousSchema_1 {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "asyncapi-from-v1-parser": {
        "description": "# AsyncAPI from parser\n\nA basic example of how to use Modelina with an AsyncAPI instance from the AsyncAPI parser.\n\n",
        "displayName": "asyncapi-from-v1-parser",
        "code": "// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst parser = require('@asyncapi/parserV1');\nimport { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst AsyncAPIDocument = {\n  asyncapi: '2.2.0',\n  info: {\n    title: 'example',\n    version: '0.1.0'\n  },\n  channels: {\n    '/test': {\n      subscribe: {\n        message: {\n          payload: {\n            $schema: 'http://json-schema.org/draft-07/schema#',\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              email: {\n                type: 'string',\n                format: 'email'\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const parsedDoc = await parser.parse(JSON.stringify(AsyncAPIDocument));\n  const models = await generator.generate(parsedDoc);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class AnonymousSchema_1 {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "change-type-mapping": {
        "description": "# Change type mapping\n\nThis example shows how to overwrite the default type mapping, and in this case we overwrite the default rendering of the FloatModel `number` and instead use `integer`.\n\n",
        "displayName": "change-type-mapping",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  typeMapping: {\n    String: ({\n      constrainedModel,\n      options,\n      partOfProperty,\n      dependencyManager\n    }) => {\n      return 'integer';\n    }\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: integer;\n\n  constructor(input: {\n    email?: integer,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): integer | undefined { return this._email; }\n  set email(email: integer | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "change-type-mapping-with-dependency": {
        "description": "# Change type mapping that adds a new dependency\n\nThis example shows how to use a new custom type for the FloatModel, that changes its type from `number` to `MyCustomClass`, which also needs to be added as a dependency.\n\n",
        "displayName": "change-type-mapping-with-dependency",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  typeMapping: {\n    Float: ({ dependencyManager }) => {\n      // Let let the TypeScript dependency manager handle rendering the dependency based on the TypeScript options (i.e moduleSystem).\n      dependencyManager.addTypeScriptDependency(\n        'MyCustomClass',\n        '../some/path/to/MyCustomClass'\n      );\n      // Or just do it manually, but then the moduleSystem options is not uphold. This is what most generators support\n      // dependencyManager.addDependency('import MyCustomClass from \\'../some/path/to/class\\';');\n\n      // Return the type to use for this float model\n      return 'MyCustomClass';\n    }\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    someProperty: {\n      type: 'number'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _someProperty?: MyCustomClass;\n\n  constructor(input: {\n    someProperty?: MyCustomClass,\n  }) {\n    this._someProperty = input.someProperty;\n  }\n\n  get someProperty(): MyCustomClass | undefined { return this._someProperty; }\n  set someProperty(someProperty: MyCustomClass | undefined) { this._someProperty = someProperty; }\n}",
        "language": "typescript"
    },
    "csharp-auto-implemented-properties": {
        "description": "# CSharp auto-implemented properties\n\nA basic example to render auto-implemented properties in CSharp\n\n",
        "displayName": "csharp-auto-implemented-properties",
        "code": "import { CSharpGenerator, CSHARP_DEFAULT_PRESET } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  presets: [\n    {\n      preset: CSHARP_DEFAULT_PRESET,\n      options: {\n        autoImplementedProperties: true\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    emails: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    },\n    stringProp: {\n      type: 'string'\n    },\n    numberProp: {\n      type: 'number'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root\n{\n  public dynamic[]? Emails { get; set; }\n  public string? StringProp { get; set; }\n  public double? NumberProp { get; set; }\n}",
        "language": "csharp"
    },
    "csharp-change-collection-type": {
        "description": "# C# change collection type\n\nA basic example to render collections as IEnumerable type in C#.\n\n",
        "displayName": "csharp-change-collection-type",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  collectionType: 'List'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root\n{\n  private IEnumerable<dynamic>? email;\n\n  public IEnumerable<dynamic>? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n}",
        "language": "csharp"
    },
    "csharp-generate-equals-and-hashcode": {
        "description": "# C# Generate `Equal` and `GetHashCode`\n\nA basic example on how to generate models that overwrite the `Equal` and `GetHashCode` methods\n\n",
        "displayName": "csharp-generate-equals-and-hashcode",
        "code": "import { CSharpGenerator, CSHARP_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  presets: [\n    {\n      preset: CSHARP_COMMON_PRESET,\n      options: {\n        equal: true,\n        hashCode: true\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root\n{\n  private string? email;\n\n  public string? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n\n  public override bool Equals(object obj)\n  {\n    if(obj is Root model)\n    {\n      if(ReferenceEquals(this, model)) { return true; }\n      return Email == model.Email;\n    }\n\n    return false;\n  }\n\n  public override int GetHashCode()\n  {\n    HashCode hash = new HashCode();\n    hash.Add(Email);\n    return hash.ToHashCode();\n  }\n}",
        "language": "csharp"
    },
    "csharp-generate-json-serializer": {
        "description": "# C# Generate serializer functions\n\nA basic example of how to generate models and which includes a way to serialize them into JSON.\n\n",
        "displayName": "csharp-generate-json-serializer",
        "code": "import { CSharpGenerator, CSHARP_JSON_SERIALIZER_PRESET } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  presets: [CSHARP_JSON_SERIALIZER_PRESET]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "[JsonConverter(typeof(RootConverter))]\npublic class Root\n{\n  private string? email;\n\n  public string? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n}\n\ninternal class RootConverter : JsonConverter<Root>\n{\n  public override bool CanConvert(System.Type objectType)\n  {\n    // this converter can be applied to any type\n    return true;\n  }\n  public override Root Read(ref Utf8JsonReader reader, System.Type typeToConvert, JsonSerializerOptions options)\n  {\n    if (reader.TokenType != JsonTokenType.StartObject)\n    {\n      throw new JsonException();\n    }\n\n    var instance = new Root();\n  \n    while (reader.Read())\n    {\n      if (reader.TokenType == JsonTokenType.EndObject)\n      {\n        return instance;\n      }\n\n      // Get the key.\n      if (reader.TokenType != JsonTokenType.PropertyName)\n      {\n        throw new JsonException();\n      }\n\n      string propertyName = reader.GetString();\n      if (propertyName == \"email\")\n        {\n          var value = JsonSerializer.Deserialize<string?>(ref reader, options);\n          instance.email = value;\n          continue;\n        }\n    }\n  \n    throw new JsonException();\n  }\n  public override void Write(Utf8JsonWriter writer, Root value, JsonSerializerOptions options)\n  {\n    if (value == null)\n    {\n      JsonSerializer.Serialize(writer, null, options);\n      return;\n    }\n    var properties = value.GetType().GetProperties();\n  \n    writer.WriteStartObject();\n\n    if(value.email != null) { \n      // write property name and let the serializer serialize the value itself\n      writer.WritePropertyName(\"email\");\n      JsonSerializer.Serialize(writer, value.email, options);\n    }\n\n\n    writer.WriteEndObject();\n  }\n\n}\n",
        "language": "csharp"
    },
    "csharp-generate-newtonsoft-serializer": {
        "description": "# C# Generate serializer functions for Newtonsoft\n\nA basic example of how to generate models and which includes a way to serialize them into and from JSON using Newtonsoft.\n\n",
        "displayName": "csharp-generate-newtonsoft-serializer",
        "code": "import {\n  CSharpGenerator,\n  CSHARP_NEWTONSOFT_SERIALIZER_PRESET\n} from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  presets: [CSHARP_NEWTONSOFT_SERIALIZER_PRESET]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "[JsonConverter(typeof(RootConverter))]\npublic class Root\n{\n  private string? email;\n\n  public string? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n}\n\npublic class RootConverter : JsonConverter<Root>\n{\n  public override Root ReadJson(JsonReader reader, System.Type objectType, Root existingValue, bool hasExistingValue, JsonSerializer serializer)\n{\n  JObject jo = JObject.Load(reader);\n  Root value = new Root();\n\n  if(jo[\"email\"] != null) {\n  value.Email = jo[\"email\"].ToObject<string?>(serializer);\n}\n\n  \n  return value;\n}\n  public override void WriteJson(JsonWriter writer, Root value, JsonSerializer serializer)\n{\n  JObject jo = new JObject();\n\n  if (value.Email != null)\n{\n  jo.Add(\"email\", JToken.FromObject(value.Email, serializer));\n}\n  \n\n  jo.WriteTo(writer);\n}\n\n  public override bool CanRead => true;\n  public override bool CanWrite => true;\n}",
        "language": "csharp"
    },
    "csharp-generate-records": {
        "description": "# TODO: Your example title\n\nTODO: Your example description\n\n",
        "displayName": "csharp-generate-records",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  modelType: 'record',\n  collectionType: 'List'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  required: ['name'],\n  properties: {\n    email: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    },\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public record Root\n{\n  public IEnumerable<dynamic>? Email { get; init; }\n  public required string Name { get; init; }\n}",
        "language": "csharp"
    },
    "csharp-generate-required-properties": {
        "description": "# C# Generate required properties\n\nAn example showing that when a property of a not-nullable type (value type) is set as required, it's not going to be made into nullable.\n\n",
        "displayName": "csharp-generate-required-properties",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    requiredBoolean: {\n      type: 'boolean'\n    },\n    notRequiredBoolean: {\n      type: 'boolean'\n    },\n    requiredString: {\n      type: 'string'\n    },\n    notRequiredString: {\n      type: 'string'\n    }\n  },\n  required: ['requiredBoolean', 'requiredString']\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root\n{\n  private bool requiredBoolean;\n  private bool? notRequiredBoolean;\n  private string requiredString;\n  private string? notRequiredString;\n\n  public bool RequiredBoolean \n  {\n    get { return requiredBoolean; }\n    set { requiredBoolean = value; }\n  }\n\n  public bool? NotRequiredBoolean \n  {\n    get { return notRequiredBoolean; }\n    set { notRequiredBoolean = value; }\n  }\n\n  public string RequiredString \n  {\n    get { return requiredString; }\n    set { requiredString = value; }\n  }\n\n  public string? NotRequiredString \n  {\n    get { return notRequiredString; }\n    set { notRequiredString = value; }\n  }\n}",
        "language": "csharp"
    },
    "csharp-overwrite-enum-naming": {
        "description": "# C# Generate custom enum value names\n\nA basic example of how to custom enum value names.\n\n",
        "displayName": "csharp-overwrite-enum-naming",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\nimport { DefaultEnumKeyConstraints } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  constraints: {\n    enumKey: ({ enumModel, enumKey }) => {\n      // Lets see if an enum has an associated custom name\n      const hasCustomName =\n        enumModel.originalInput !== undefined &&\n        enumModel.originalInput['x-enumNames'] !== undefined;\n      if (hasCustomName) {\n        // Lets see if the specific value has an associated name\n        const customName = enumModel.originalInput['x-enumNames'][enumKey];\n        if (customName !== undefined) {\n          return customName;\n        }\n      }\n    }\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  title: 'OrderStatus',\n  type: 'number',\n  enum: [30, 40, 50, 99],\n  'x-enumNames': {\n    30: 'Ordered',\n    40: 'UnderDelivery',\n    50: 'Delivered',\n    99: 'Cancelled'\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public enum OrderStatus\n{\n  Ordered,\n  UnderDelivery,\n  Delivered,\n  Cancelled\n}\n\npublic static class OrderStatusExtensions\n{\n  public static int? GetValue(this OrderStatus enumValue)\n  {\n    switch (enumValue)\n    {\n      case OrderStatus.Ordered: return 30;\n      case OrderStatus.UnderDelivery: return 40;\n      case OrderStatus.Delivered: return 50;\n      case OrderStatus.Cancelled: return 99;\n    }\n    return null;\n  }\n\n  public static OrderStatus? ToOrderStatus(int? value)\n  {\n    switch (value)\n    {\n      case 30: return OrderStatus.Ordered;\n      case 40: return OrderStatus.UnderDelivery;\n      case 50: return OrderStatus.Delivered;\n      case 99: return OrderStatus.Cancelled;\n    }\n    return null;\n  }\n}\n",
        "language": "csharp"
    },
    "csharp-use-inheritance": {
        "description": "# C# use inheritance\n\nA basic example that renders the models with a custom inheritance.\n\n",
        "displayName": "csharp-use-inheritance",
        "code": "import { ConstrainedDictionaryModel, CSharpGenerator } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator({\n  presets: [\n    {\n      class: {\n        // Self is used to overwrite the entire rendering behavior of the class\n        self: async ({ renderer, options, model }) => {\n          //Render all the class content\n          const content = [\n            await renderer.renderProperties(),\n            await renderer.runCtorPreset(),\n            await renderer.renderAccessors(),\n            await renderer.runAdditionalContentPreset()\n          ];\n\n          if (\n            options?.collectionType === 'List' ||\n            model.containsPropertyType(ConstrainedDictionaryModel)\n          ) {\n            renderer.addDependency('using System.Collections.Generic;');\n          }\n          return `public class ${model.name} : IEvent\n{\n${renderer.indent(renderer.renderBlock(content, 2))}\n}`;\n        }\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'array',\n      additionalItems: false,\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root : IEvent\n{\n  private string[]? email;\n\n  public string[]? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n}",
        "language": "csharp"
    },
    "custom-logging": {
        "description": "# Custom logger\n\nA basic example of how to use Modelina with a custom logger.\n\n",
        "displayName": "custom-logging",
        "code": "import { TypeScriptGenerator, ModelLoggingInterface, Logger } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\nconst customLogger: ModelLoggingInterface = {\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\nLogger.setLogger(customLogger);\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "dart-generate-json-annotation": {
        "description": "# Dart Data Models with json_annotation\n\nA basic example of how to use Modelina and output a Go data model.\n\n",
        "displayName": "dart-generate-json-annotation",
        "code": "import { DART_JSON_PRESET, DartFileGenerator } from '@asyncapi/modelina';\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: true,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nconst generator = new DartFileGenerator({ presets: [DART_JSON_PRESET] });\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  String? email;\n  Map<String, Object>? additionalProperties;\n\n  Root();\n\n  factory Root.fromJson(Map<String, dynamic> json) => _$RootFromJson(json);\n  Map<String, dynamic> toJson() => _$RootToJson(this);\n}",
        "language": "dart"
    },
    "generate-all-models-within-the-same-file": {
        "description": "# Generate all models within the same file\n\nA basic example of how to generate all models within the same file.\n\n",
        "displayName": "generate-all-models-within-the-same-file",
        "code": "import { JavaFileGenerator } from '@asyncapi/modelina';\nimport { promises as fsPromises } from 'fs';\n\nconst generator = new JavaFileGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      enum: ['example1@test.com', 'example2@test.com']\n    }\n  }\n};\nexport async function generate(): Promise<void> {\n  const outputFile = './output';\n  const models = await generator.generate(jsonSchemaDraft7);\n  const modelCode = models.map((outputModel) => {\n    return outputModel.result;\n  });\n  const imports = models.map((outputModel) => {\n    return outputModel.dependencies;\n  });\n  const uniqueImports = [...new Set(imports)];\n  const codeWithImports = `${uniqueImports.join('\\n')}\n  ${modelCode.join('\\n')}`;\n\n  await fsPromises.writeFile(outputFile, codeWithImports);\n  console.log(codeWithImports);\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\n\n  public class Root {\n  private Email email;\n\n  public Email getEmail() { return this.email; }\n  public void setEmail(Email email) { this.email = email; }\n}\npublic enum Email {\n  EXAMPLE1_AT_TEST_DOT_COM((String)\"example1@test.com\"), EXAMPLE2_AT_TEST_DOT_COM((String)\"example2@test.com\");\n\n  private String value;\n\n  Email(String value) {\n    this.value = value;\n  }\n\n  public String getValue() {\n    return value;\n  }\n\n  public static Email fromValue(String value) {\n    for (Email e : Email.values()) {\n      if (e.value.equals(value)) {\n        return e;\n      }\n    }\n    throw new IllegalArgumentException(\"Unexpected value '\" + value + \"'\");\n  }\n\n  @Override\n  public String toString() {\n    return String.valueOf(value);\n  }\n}",
        "language": "typescript"
    },
    "generate-cplusplus-models": {
        "description": "# C++ Data Models\n\nA basic example of how to use Modelina and output a C++ data model.\n\n",
        "displayName": "generate-cplusplus-models",
        "code": "import { CplusplusGenerator } from '@asyncapi/modelina';\n\nconst generator = new CplusplusGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "struct root {\n  std::optional<std::string> email;\n};",
        "language": "typescript"
    },
    "generate-csharp-models": {
        "description": "# C# data models\n\nA basic example of how to use Modelina and output a C# data model.\n\n",
        "displayName": "generate-csharp-models",
        "code": "import { CSharpGenerator } from '@asyncapi/modelina';\n\nconst generator = new CSharpGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root\n{\n  private string? email;\n\n  public string? Email \n  {\n    get { return email; }\n    set { email = value; }\n  }\n}",
        "language": "csharp"
    },
    "generate-dart-models": {
        "description": "# Dart Data Models\n\nA basic example of how to use Modelina and output a Go data model.\n\n",
        "displayName": "generate-dart-models",
        "code": "import { DartGenerator } from '@asyncapi/modelina';\n\nconst generator = new DartGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  String? email;\n\n  Root();\n}",
        "language": "dart"
    },
    "generate-go-enums": {
        "description": "# Go Enum Models\n\nA basic example of how Modelina renders enum values in Go.\n\n",
        "displayName": "generate-go-enums",
        "code": "import { GoGenerator } from '@asyncapi/modelina';\n\nconst generator = new GoGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    cities: {\n      $id: 'cities',\n      type: 'string',\n      enum: ['London', 'Rome', 'Brussels']\n    },\n    options: {\n      $id: 'options',\n      type: ['integer', 'boolean', 'string'],\n      enum: [123, 213, true, 'Run']\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "// Root represents a Root model.\ntype Root struct {\n  Cities *Cities\n  Options *Options\n}\n\n// Cities represents an enum of Cities.\ntype Cities uint\n\nconst (\n  CitiesLondon Cities = iota\n  CitiesRome\n  CitiesBrussels\n)\n\n// Value returns the value of the enum.\nfunc (op Cities) Value() any {\n\tif op >= Cities(len(CitiesValues)) {\n\t\treturn nil\n\t}\n\treturn CitiesValues[op]\n}\n\nvar CitiesValues = []any{\"London\",\"Rome\",\"Brussels\"}\nvar ValuesToCities = map[any]Cities{\n  CitiesValues[CitiesLondon]: CitiesLondon,\n  CitiesValues[CitiesRome]: CitiesRome,\n  CitiesValues[CitiesBrussels]: CitiesBrussels,\n}\n\n\n// Options represents an enum of Options.\ntype Options uint\n\nconst (\n  OptionsNumber_123 Options = iota\n  OptionsNumber_213\n  OptionsTrue\n  OptionsRun\n)\n\n// Value returns the value of the enum.\nfunc (op Options) Value() any {\n\tif op >= Options(len(OptionsValues)) {\n\t\treturn nil\n\t}\n\treturn OptionsValues[op]\n}\n\nvar OptionsValues = []any{123,213,true,\"Run\"}\nvar ValuesToOptions = map[any]Options{\n  OptionsValues[OptionsNumber_123]: OptionsNumber_123,\n  OptionsValues[OptionsNumber_213]: OptionsNumber_213,\n  OptionsValues[OptionsTrue]: OptionsTrue,\n  OptionsValues[OptionsRun]: OptionsRun,\n}\n",
        "language": "go"
    },
    "generate-go-models": {
        "description": "# Go Data Models\n\nA basic example of how to use Modelina and output a Go data model.\n\n",
        "displayName": "generate-go-models",
        "code": "import { GoGenerator } from '@asyncapi/modelina';\n\nconst generator = new GoGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "// Root represents a Root model.\ntype Root struct {\n  Email string\n}",
        "language": "go"
    },
    "generate-java-models": {
        "description": "# Java Data Models\n\nA basic example of how to use Modelina and output a Java data model.\n\n",
        "displayName": "generate-java-models",
        "code": "import { JavaGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n}",
        "language": "java"
    },
    "generate-javascript-models": {
        "description": "# Generate JavaScript Models\n\nA basic example to generate JavaScript data models\n\n",
        "displayName": "generate-javascript-models",
        "code": "import { JavaScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaScriptGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  email;\n\n  constructor(input) {\n    if (input.hasOwnProperty('email')) {\n      this.email = input.email;\n    }\n  }\n\n  get email() { return this.email; }\n  set email(email) { this.email = email; }\n}",
        "language": "java"
    },
    "generate-kotlin-enums": {
        "description": "# Kotlin Enums\n\nA basic example of how to use Modelina and output a Kotlin enum.\n\n",
        "displayName": "generate-kotlin-enums",
        "code": "import { KotlinGenerator } from '@asyncapi/modelina';\n\nconst generator = new KotlinGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  additionalProperties: false,\n  $id: 'protocol',\n  type: ['string', 'int', 'boolean'],\n  enum: ['HTTP', 1, 'HTTPS', true]\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "enum class Protocol(val value: Any) {\n    HTTP(\"HTTP\"), \n    NUMBER_1(1), \n    HTTPS(\"HTTPS\"), \n    TRUE(true);\n}",
        "language": "kotlin"
    },
    "generate-kotlin-models": {
        "description": "# Kotlin Data Models\n\nA basic example of how to use Modelina and output a Kotlin data model.\n\n",
        "displayName": "generate-kotlin-models",
        "code": "import { KotlinGenerator } from '@asyncapi/modelina';\n\nconst generator = new KotlinGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    },\n    cache: {\n      type: 'integer'\n    },\n    website: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        domain: {\n          type: 'string',\n          format: 'url'\n        },\n        protocol: {\n          type: 'string',\n          enum: ['HTTP', 'HTTPS']\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "data class Root(\n    val email: String,\n    val cache: Int,\n    val website: Website,\n)",
        "language": "kotlin"
    },
    "generate-python-complete-models": {
        "description": "# Python models\n\nA basic example of complete model generation.\n\n",
        "displayName": "generate-python-complete-models",
        "code": "import { PythonGenerator } from '@asyncapi/modelina';\n\nexport const jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    },\n    objProperty: {\n      type: 'object',\n      properties: {\n        number: {\n          type: 'number'\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const generator = new PythonGenerator();\n\n  let models = await generator.generateCompleteModels(jsonSchemaDraft7, {\n    importsStyle: 'implicit'\n  });\n\n  for (const model of models) {\n    console.log(model.result);\n  }\n\n  models = await generator.generateCompleteModels(jsonSchemaDraft7, {\n    importsStyle: 'explicit'\n  });\n\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\n\nclass ObjProperty: \n  def __init__(self, input):\n    if hasattr(input, 'number'):\n    \tself._number = input.number\n    if hasattr(input, 'additionalProperties'):\n    \tself._additionalProperties = input.additionalProperties\n\n  @property\n  def number(self):\n  \treturn self._number\n  @number.setter\n  def number(self, number):\n  \tself._number = number\n\n  @property\n  def additionalProperties(self):\n  \treturn self._additionalProperties\n  @additionalProperties.setter\n  def additionalProperties(self, additionalProperties):\n  \tself._additionalProperties = additionalProperties\n\n\n\n\nclass ObjProperty: \n  def __init__(self, input):\n    if hasattr(input, 'number'):\n    \tself._number = input.number\n    if hasattr(input, 'additionalProperties'):\n    \tself._additionalProperties = input.additionalProperties\n\n  @property\n  def number(self):\n  \treturn self._number\n  @number.setter\n  def number(self, number):\n  \tself._number = number\n\n  @property\n  def additionalProperties(self):\n  \treturn self._additionalProperties\n  @additionalProperties.setter\n  def additionalProperties(self, additionalProperties):\n  \tself._additionalProperties = additionalProperties\n\n\nfrom ObjProperty import ObjProperty\n\nclass Root: \n  def __init__(self, input):\n    if hasattr(input, 'email'):\n    \tself._email = input.email\n    if hasattr(input, 'objProperty'):\n    \tself._objProperty = input.objProperty\n\n  @property\n  def email(self):\n  \treturn self._email\n  @email.setter\n  def email(self, email):\n  \tself._email = email\n\n  @property\n  def objProperty(self):\n  \treturn self._objProperty\n  @objProperty.setter\n  def objProperty(self, objProperty):\n  \tself._objProperty = objProperty\n\n\nfrom ObjProperty import ObjProperty\n\nclass Root: \n  def __init__(self, input):\n    if hasattr(input, 'email'):\n    \tself._email = input.email\n    if hasattr(input, 'objProperty'):\n    \tself._objProperty = input.objProperty\n\n  @property\n  def email(self):\n  \treturn self._email\n  @email.setter\n  def email(self, email):\n  \tself._email = email\n\n  @property\n  def objProperty(self):\n  \treturn self._objProperty\n  @objProperty.setter\n  def objProperty(self, objProperty):\n  \tself._objProperty = objProperty\n",
        "language": "python"
    },
    "generate-python-models": {
        "description": "# Python models\n\nA basic example of how to use Modelina and output a Python data model.\n\n",
        "displayName": "generate-python-models",
        "code": "import { PythonGenerator } from '@asyncapi/modelina';\n\nconst generator = new PythonGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root: \n  def __init__(self, input):\n    if hasattr(input, 'email'):\n    \tself._email = input.email\n\n  @property\n  def email(self):\n  \treturn self._email\n  @email.setter\n  def email(self, email):\n  \tself._email = email\n",
        "language": "python"
    },
    "generate-python-pydantic-models": {
        "description": "# Python Pydantic models\n\nA basic example of how to use Modelina and output a Python Pydantic data model.\n\n",
        "displayName": "generate-python-pydantic-models",
        "code": "import { PythonGenerator, PYTHON_PYDANTIC_PRESET } from '@asyncapi/modelina';\n\nconst generator = new PythonGenerator({\n  presets: [PYTHON_PYDANTIC_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  required: ['requiredField'],\n  properties: {\n    optionalField: {\n      type: 'string',\n      format: 'email',\n      description: 'this field is optional'\n    },\n    requiredField: {\n      type: 'string',\n      format: 'email',\n      description: 'this field is required'\n    },\n    noDescription: {\n      type: 'string'\n    },\n    options: {\n      $id: 'options',\n      type: ['integer', 'boolean', 'string'],\n      enum: [123, 213, true, 'Run']\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root(BaseModel): \n  optionalField: Optional[str] = Field(alias='this field is optional')\n  requiredField: str = Field(alias='this field is required')\n  noDescription: Optional[str] = Field()\n  options: Optional[Options] = Field()\n\n\nclass Options(Enum): \n  NUMBER_123 = 123\n  NUMBER_213 = 213\n  RESERVED_TRUE = \"true\"\n  RUN = \"Run\"",
        "language": "python"
    },
    "generate-to-files": {
        "description": "# Generate models to files\n\nA basic example how to generate the models to files.\n\n",
        "displayName": "generate-to-files",
        "code": "import { JavaFileGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaFileGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const outputFolder = './examples/generate-to-files/output';\n  const modelGenerationOptions = {\n    packageName: 'TestPackageName'\n  };\n  const models = await generator.generateToFiles(\n    jsonSchemaDraft7,\n    outputFolder,\n    modelGenerationOptions\n  );\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "package TestPackageName;\n\n\npublic class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n}",
        "language": "typescript"
    },
    "generate-typescript-models": {
        "description": "# TypeScript Data Models\n\nA basic example of how to use Modelina and output a TypeScript data model.\n\n",
        "displayName": "generate-typescript-models",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "include-custom-function": {
        "description": "# Custom Function\n\nA basic example of how to include custom function in data model.\n\n",
        "displayName": "include-custom-function",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  presets: [\n    {\n      class: {\n        additionalContent({ content }) {\n          return `${content}\npublic someAdditionalFunctionForClasses(): string {\n  return 'Some test';\n}`;\n        }\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n\n\n  public someAdditionalFunctionForClasses(): string {\n    return 'Some test';\n  }\n}",
        "language": "typescript"
    },
    "indentation-type-and-size": {
        "description": "# Indentation type and size\n\nThis example shows how to change the indentation type and size of the generated model.\n\n",
        "displayName": "indentation-type-and-size",
        "code": "import { TypeScriptGenerator, IndentationTypes } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  indentation: {\n    type: IndentationTypes.TABS,\n    size: 4\n  }\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n\t\t\t\tprivate _email?: string;\n\n\t\t\t\tconstructor(input: {\n\t\t\t\t\t\t\t\temail?: string,\n\t\t\t\t}) {\n\t\t\t\t\t\t\t\tthis._email = input.email;\n\t\t\t\t}\n\n\t\t\t\tget email(): string | undefined { return this._email; }\n\t\t\t\tset email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "java-change-collection-type": {
        "description": "# Java change collection type\n\nA basic example to render collections as List type in Java.\n\n",
        "displayName": "java-change-collection-type",
        "code": "import { JavaGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  collectionType: 'List'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'array',\n      additionalItems: false,\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private List<String> email;\n\n  public List<String> getEmail() { return this.email; }\n  public void setEmail(List<String> email) { this.email = email; }\n}",
        "language": "java"
    },
    "java-from-typescript-type": {
        "description": "# Generate Java from a TypeScript Types file\n\nThis is a basic example of generating Java models using a Typescript type file as input. This can be extended to generating Go, C# and other supported language models.\n\n",
        "displayName": "java-from-typescript-type",
        "code": "import { JavaGenerator } from '@asyncapi/modelina';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst generator = new JavaGenerator();\n\nconst file = path.resolve(__dirname, './typescriptFile.ts');\nconst fileContents = fs.readFileSync(\n  path.resolve(__dirname, './typescriptFile.ts'),\n  'utf-8'\n);\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate({\n    fileContents,\n    baseFile: file\n  });\n\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class InnerData {\n  private Double age;\n  private String name;\n  private Boolean free;\n  private Map<String, Object> additionalProperties;\n\n  public Double getAge() { return this.age; }\n  public void setAge(Double age) { this.age = age; }\n\n  public String getName() { return this.name; }\n  public void setName(String name) { this.name = name; }\n\n  public Boolean getFree() { return this.free; }\n  public void setFree(Boolean free) { this.free = free; }\n\n  public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; }\n  public void setAdditionalProperties(Map<String, Object> additionalProperties) { this.additionalProperties = additionalProperties; }\n}",
        "language": "typescript"
    },
    "java-from-typescript-type-with-options": {
        "description": "# TODO: Generate Java model from a TypeScript Types file using processor options\n\nThis is a basic example of generating Java models using a Typescript type file as input and processor options. This can be extended to generating Go, C# and other supported language models.\n\n",
        "displayName": "java-from-typescript-type-with-options",
        "code": "import { JavaGenerator } from '@asyncapi/modelina';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst generator = new JavaGenerator({\n  processorOptions: {\n    typescript: {\n      compilerOptions: {\n        strictNullChecks: true\n      }\n    }\n  }\n});\n\nconst file = path.resolve(__dirname, './typescriptFile.ts');\nconst fileContents = fs.readFileSync(\n  path.resolve(__dirname, './typescriptFile.ts'),\n  'utf-8'\n);\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate({\n    fileContents,\n    baseFile: file\n  });\n\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class OuterData {\n  private Object inner;\n  private String name;\n  private Map<String, Object> additionalProperties;\n\n  public Object getInner() { return this.inner; }\n  public void setInner(Object inner) { this.inner = inner; }\n\n  public String getName() { return this.name; }\n  public void setName(String name) { this.name = name; }\n\n  public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; }\n  public void setAdditionalProperties(Map<String, Object> additionalProperties) { this.additionalProperties = additionalProperties; }\n}",
        "language": "typescript"
    },
    "java-generate-equals": {
        "description": "# Java Generate `Equal`\n\nA basic example on how to generate models that overwrite the `Equal` methods\n\n",
        "displayName": "java-generate-equals",
        "code": "import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [\n    {\n      preset: JAVA_COMMON_PRESET,\n      options: {\n        equal: true,\n        hashCode: false,\n        classToString: false,\n        marshalling: false\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Root self = (Root) o;\n      return \n        Objects.equals(this.email, self.email);\n  }\n}",
        "language": "java"
    },
    "java-generate-hashcode": {
        "description": "# Java Generate `HashCode`\n\nA basic example on how to generate models that overwrite `hashCode` method\n\n",
        "displayName": "java-generate-hashcode",
        "code": "import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [\n    {\n      preset: JAVA_COMMON_PRESET,\n      options: {\n        equal: false,\n        hashCode: true,\n        classToString: false,\n        marshalling: false\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash((Object)email);\n  }\n}",
        "language": "java"
    },
    "java-generate-jackson-annotation": {
        "description": "# Java Generate Jackson Annotation\n\nA basic example on how to generate models for jackson annotation\n\n",
        "displayName": "java-generate-jackson-annotation",
        "code": "import { JavaGenerator, JAVA_JACKSON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [JAVA_JACKSON_PRESET]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    min_number_prop: { type: 'number' },\n    max_number_prop: { type: 'number' }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  @JsonProperty(\"min_number_prop\")\n  private Double minNumberProp;\n  @JsonProperty(\"max_number_prop\")\n  private Double maxNumberProp;\n  private Map<String, Object> additionalProperties;\n\n  public Double getMinNumberProp() { return this.minNumberProp; }\n  public void setMinNumberProp(Double minNumberProp) { this.minNumberProp = minNumberProp; }\n\n  public Double getMaxNumberProp() { return this.maxNumberProp; }\n  public void setMaxNumberProp(Double maxNumberProp) { this.maxNumberProp = maxNumberProp; }\n\n  public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; }\n  public void setAdditionalProperties(Map<String, Object> additionalProperties) { this.additionalProperties = additionalProperties; }\n}",
        "language": "java"
    },
    "java-generate-javadoc": {
        "description": "# JavaDocs\n\nA basic example of how to generate Java models by including JavaDocs in description and examples.\n\n",
        "displayName": "java-generate-javadoc",
        "code": "import { JavaGenerator, JAVA_DESCRIPTION_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [JAVA_DESCRIPTION_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'JavaDoc',\n  type: 'object',\n  description: 'Description for class',\n  examples: [{ prop: 'value' }],\n  properties: {\n    prop: {\n      type: 'string',\n      description: 'Description for prop',\n      examples: ['exampleValue']\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "/**\n * Description for class\n * Examples: {\"prop\":\"value\"}\n */\npublic class JavaDoc {\n  private String prop;\n  private Map<String, Object> additionalProperties;\n\n  /**\n   * Description for prop\n   * Examples: exampleValue\n   */\n  public String getProp() { return this.prop; }\n  public void setProp(String prop) { this.prop = prop; }\n\n  public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; }\n  public void setAdditionalProperties(Map<String, Object> additionalProperties) { this.additionalProperties = additionalProperties; }\n}",
        "language": "java"
    },
    "java-generate-javax-constraint-annotation": {
        "description": "# Javax validation constraints annotations\n\nA basic example that shows how Java data models having `javax.validation.constraints` annotations can be generated.\n\n",
        "displayName": "java-generate-javax-constraint-annotation",
        "code": "import { JavaGenerator, JAVA_CONSTRAINTS_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [JAVA_CONSTRAINTS_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'JavaxAnnotation',\n  type: 'object',\n  properties: {\n    min_number_prop: { type: 'number', minimum: 0 },\n    max_number_prop: { type: 'number', exclusiveMaximum: 100 },\n    array_prop: { type: 'array', minItems: 2, maxItems: 3 },\n    string_prop: { type: 'string', pattern: '^I_', minLength: 3 }\n  },\n  required: ['min_number_prop', 'max_number_prop']\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class JavaxAnnotation {\n  @NotNull\n  @Min(0)\n  private Double minNumberProp;\n  @NotNull\n  @Max(99)\n  private Double maxNumberProp;\n  @Size(min=2, max=3)\n  private Object[] arrayProp;\n  @Pattern(regexp=\"^I_\")\n  @Size(min=3)\n  private String stringProp;\n  private Map<String, Object> additionalProperties;\n\n  public Double getMinNumberProp() { return this.minNumberProp; }\n  public void setMinNumberProp(Double minNumberProp) { this.minNumberProp = minNumberProp; }\n\n  public Double getMaxNumberProp() { return this.maxNumberProp; }\n  public void setMaxNumberProp(Double maxNumberProp) { this.maxNumberProp = maxNumberProp; }\n\n  public Object[] getArrayProp() { return this.arrayProp; }\n  public void setArrayProp(Object[] arrayProp) { this.arrayProp = arrayProp; }\n\n  public String getStringProp() { return this.stringProp; }\n  public void setStringProp(String stringProp) { this.stringProp = stringProp; }\n\n  public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; }\n  public void setAdditionalProperties(Map<String, Object> additionalProperties) { this.additionalProperties = additionalProperties; }\n}",
        "language": "java"
    },
    "java-generate-marshalling": {
        "description": "# Java Data Models with un/marshalling functionality\n\nA basic example of how to use the un/marshalling functionality of the java class.\n\n",
        "displayName": "java-generate-marshalling",
        "code": "import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [\n    {\n      preset: JAVA_COMMON_PRESET,\n      options: {\n        equal: false,\n        hashCode: false,\n        classToString: false,\n        marshalling: true\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n\n  public String marshal() {\n    List<String> propList = new ArrayList();\n      if(this.email != null) {\n            propList.add(\"email:\"+this.email.toString());\n        }\n    return propList.stream().collect(Collectors.joining(\",\"));\n  }\n\n  public static Root unmarshal(String json) {\n    Root result = new Root();\n    JSONObject jsonObject = new JSONObject(json);\n      if(jsonObject.has(\"email\")) {\n            result.setEmail(jsonObject.getString(\"email\"));\n          }\n    return result;\n  }\n}",
        "language": "java"
    },
    "java-generate-tostring": {
        "description": "# Java Generate toString\n\nA basic example on how to generate models that overwrite the `toString` method\n\n\n",
        "displayName": "java-generate-tostring",
        "code": "import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaGenerator({\n  presets: [\n    {\n      preset: JAVA_COMMON_PRESET,\n      options: {\n        equal: false,\n        hashCode: false,\n        classToString: true,\n        marshalling: false\n      }\n    }\n  ]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "public class Root {\n  private String email;\n\n  public String getEmail() { return this.email; }\n  public void setEmail(String email) { this.email = email; }\n\n  @Override\n  public String toString() {\n    return \"class Root {n\" +   \n      \"    email: \" + toIndentedString(email) + \"n\" +\n    \"}\";\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"n\", \"n    \");\n  }\n}",
        "language": "java"
    },
    "javascript-generate-example": {
        "description": "# JavaScript Data Models with example function\n\nA basic example of how to use Modelina and output a TypeScript class with an example function.\n\n\n",
        "displayName": "javascript-generate-example",
        "code": "import { JavaScriptGenerator } from '@asyncapi/modelina';\nimport { JS_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaScriptGenerator({\n  presets: [\n    {\n      preset: JS_COMMON_PRESET,\n      options: {\n        example: true\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  email;\n\n  constructor(input) {\n    if (input.hasOwnProperty('email')) {\n      this.email = input.email;\n    }\n  }\n\n  get email() { return this.email; }\n  set email(email) { this.email = email; }\n\n  example(){\n    const instance = new Root({});\n    instance.email = \"string\";\n    return instance;\n  }\n}",
        "language": "java"
    },
    "javascript-generate-marshalling": {
        "description": "# JavaScript Data Models with un/marshalling functionality\n\nA basic example of how to use the un/marshalling functionality of the javascript class.\n\n",
        "displayName": "javascript-generate-marshalling",
        "code": "import { JavaScriptGenerator } from '@asyncapi/modelina';\nimport { JS_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new JavaScriptGenerator({\n  presets: [\n    {\n      preset: JS_COMMON_PRESET,\n      options: {\n        marshalling: true\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'Test',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Test {\n  email;\n\n  constructor(input) {\n    if (input.hasOwnProperty('email')) {\n      this.email = input.email;\n    }\n  }\n\n  get email() { return this.email; }\n  set email(email) { this.email = email; }\n\n  marshal(){\n    let json = '{'\n    if(this.email !== undefined) {\n      json += `\"email\": ${typeof this.email === 'number' || typeof this.email === 'boolean' ? this.email : JSON.stringify(this.email)},`; \n    }\n\n    //Remove potential last comma \n    return `${json.charAt(json.length-1) === ',' ? json.slice(0, json.length-1) : json}}`;\n  }\n\n  unmarshal(json){\n    const obj = typeof json === \"object\" ? json : JSON.parse(json);\n    const instance = new Test({});\n\n    if (obj[\"email\"] !== undefined) {\n      instance.email = obj[\"email\"];\n    }\n\n\n\n    //Not part of core properties\n\n    //Only go over remaining. properties \n    for (const [key, value] of Object.entries(obj).filter((([key,]) => {return ![\"email\"].includes(key);}))) {\n  \n    }\n\n    return instance;\n  }\n}",
        "language": "java"
    },
    "javascript-use-cjs": {
        "description": "# JavaScript models use CJS module system\n\nThis example shows how you can generate the models to use CJS module system.\n\n",
        "displayName": "javascript-use-cjs",
        "code": "import { JavaScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaScriptGenerator({\n  moduleSystem: 'CJS'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    person: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        email: {\n          type: 'string',\n          format: 'email'\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generateCompleteModels(jsonSchemaDraft7, {});\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\n\nclass Person {\n  email;\n\n  constructor(input) {\n    if (input.hasOwnProperty('email')) {\n      this.email = input.email;\n    }\n  }\n\n  get email() { return this.email; }\n  set email(email) { this.email = email; }\n}\nmodule.exports = Person;",
        "language": "java"
    },
    "javascript-use-esm": {
        "description": "# JavaScript models use ESM module system\n\nThis example shows how you can generate the models to use ESM module system.\n\n",
        "displayName": "javascript-use-esm",
        "code": "import { JavaScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new JavaScriptGenerator({\n  moduleSystem: 'ESM'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    person: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        email: {\n          type: 'string',\n          format: 'email'\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generateCompleteModels(jsonSchemaDraft7, {});\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\n\nclass Person {\n  email;\n\n  constructor(input) {\n    if (input.hasOwnProperty('email')) {\n      this.email = input.email;\n    }\n  }\n\n  get email() { return this.email; }\n  set email(email) { this.email = email; }\n}\nexport default Person;\n",
        "language": "java"
    },
    "json-schema-draft4-from-object": {
        "description": "# JSON Schema draft 4 \n\nA basic example of how to use Modelina with JSON Schema draft 4 input.\n\n",
        "displayName": "json-schema-draft4-from-object",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst jsonSchemaDraft4 = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft4);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "json-schema-draft6-from-object": {
        "description": "# JSON Schema draft 6\n\nA basic example of how to use Modelina with JSON Schema draft 6 input.\n\n",
        "displayName": "json-schema-draft6-from-object",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst jsonSchemaDraft6 = {\n  $schema: 'http://json-schema.org/draft-06/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft6);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\ngenerate();\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "json-schema-draft7-from-object": {
        "description": "# JSON Schema draft 7\n\nA basic example of how to use Modelina with JSON Schema draft 7 input.\n\n",
        "displayName": "json-schema-draft7-from-object",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "kotlin-change-collection-type": {
        "description": "# Kotlin change collection type\n\nA basic example to render collections as Array type in Kotlin.\n\n",
        "displayName": "kotlin-change-collection-type",
        "code": "import { KotlinGenerator } from '@asyncapi/modelina';\n\nconst generator = new KotlinGenerator({\n  collectionType: 'Array'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'array',\n      additionalItems: false,\n      items: {\n        type: 'string',\n        format: 'email'\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "data class Root(\n    val email: Array<String>,\n)",
        "language": "kotlin"
    },
    "kotlin-generate-javax-constraint-annotation": {
        "description": "# Javax validation constraints annotations\n\nA basic example that shows how Kotlin data models having `javax.validation.constraints` annotations can be generated.\n\n",
        "displayName": "kotlin-generate-javax-constraint-annotation",
        "code": "import { KotlinGenerator, KOTLIN_CONSTRAINTS_PRESET } from '@asyncapi/modelina';\n\nconst generator = new KotlinGenerator({\n  presets: [KOTLIN_CONSTRAINTS_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'JavaxAnnotation',\n  type: 'object',\n  properties: {\n    min_number_prop: { type: 'number', minimum: 0 },\n    max_number_prop: { type: 'number', exclusiveMaximum: 100 },\n    min_number_prop_exclusive: { type: 'number', exclusiveMinimum: 100 },\n    array_prop: { type: 'array', minItems: 2, maxItems: 3 },\n    string_prop: { type: 'string', pattern: '^I_', minLength: 3 }\n  },\n  required: ['min_number_prop', 'max_number_prop']\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "data class JavaxAnnotation(\n    @get:NotNull\n    @get:Min(0)\n    val minNumberProp: Double,\n    @get:NotNull\n    @get:Max(99)\n    val maxNumberProp: Double,\n    @get:Min(101)\n    val minNumberPropExclusive: Double,\n    @get:Size(min=2, max=3)\n    val arrayProp: List<Any>,\n    @get:Pattern(regexp=\"^I_\")\n    @get:Size(min=3)\n    val stringProp: String,\n    val additionalProperties: Map<String, Any>,\n)",
        "language": "java"
    },
    "kotlin-generate-kdoc": {
        "description": "# Kotlin KDoc\n\nA basic example of how to generate Kotlin models by including KDoc in description and examples.\n\n",
        "displayName": "kotlin-generate-kdoc",
        "code": "import { KotlinGenerator, KOTLIN_DESCRIPTION_PRESET } from '@asyncapi/modelina';\n\nconst generator = new KotlinGenerator({\n  presets: [KOTLIN_DESCRIPTION_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'KDoc',\n  type: 'object',\n  description: 'Description for class',\n  examples: [{ prop: 'value' }, { prop: 'test' }],\n  properties: {\n    prop: {\n      type: 'string',\n      description: 'Description for prop',\n      examples: ['exampleValue']\n    },\n    enum: {\n      type: 'string',\n      description: 'Description for enum',\n      enum: ['A', 'B', 'C']\n    },\n    nodesc: { type: 'string' }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "/**\n * Description for class\n * \n * @property prop Description for prop\n * @property enum Description for enum\n * @property nodesc\n * @property additionalProperties\n * \n * Examples: \n * {\"prop\":\"value\"}, {\"prop\":\"test\"}\n */\ndata class KDoc(\n    val prop: String,\n    val enum: Enum,\n    val nodesc: String,\n    val additionalProperties: Map<String, Any>,\n)",
        "language": "kotlin"
    },
    "meta-model": {
        "description": "# Meta model\n\nUsing the internal meta model representation, you can create your own data models from scratch, and still utilize the generators full sweep of features.\n\n",
        "displayName": "meta-model",
        "code": "import {\n  TypeScriptGenerator,\n  ObjectModel,\n  StringModel,\n  ObjectPropertyModel,\n  InputMetaModel\n} from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst customModel = new ObjectModel('SomeName', undefined, {});\nconst stringModel = new StringModel('test property name', undefined);\nconst propertyModel = new ObjectPropertyModel(\n  stringModel.name,\n  false,\n  stringModel\n);\ncustomModel.properties[propertyModel.propertyName] = propertyModel;\n\nconst inputModel = new InputMetaModel();\ninputModel.models[customModel.name] = customModel;\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(inputModel);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class SomeName {\n  private _testPropertyName?: string;\n\n  constructor(input: {\n    testPropertyName?: string,\n  }) {\n    this._testPropertyName = input.testPropertyName;\n  }\n\n  get testPropertyName(): string | undefined { return this._testPropertyName; }\n  set testPropertyName(testPropertyName: string | undefined) { this._testPropertyName = testPropertyName; }\n}",
        "language": "typescript"
    },
    "openapi-from-object": {
        "description": "# OpenAPI from object\n\nA basic example of how to use Modelina with a basic OpenAPI object.\n\n",
        "displayName": "openapi-from-object",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst swaggerDocument = {\n  openapi: '3.0.3',\n  info: {\n    version: '0.1',\n    title: 'Simple basic api'\n  },\n  paths: {\n    '/test': {\n      post: {\n        requestBody: {\n          content: {\n            'application/json': {\n              schema: {\n                $schema: 'http://json-schema.org/draft-07/schema#',\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                  email: {\n                    type: 'string',\n                    format: 'email'\n                  }\n                }\n              }\n            }\n          },\n          required: true\n        },\n        responses: {\n          200: {\n            content: {\n              'application/json': {\n                schema: {\n                  $schema: 'http://json-schema.org/draft-07/schema#',\n                  type: 'object',\n                  additionalProperties: false,\n                  properties: {\n                    email: {\n                      type: 'string',\n                      format: 'email'\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(swaggerDocument);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class TestPost_200ApplicationJson {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}\n\nclass TestPostApplicationJson {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "overwrite-default-constraint": {
        "description": "# Overwrite default constraint\n\nThis example shows how to overwrite the whole constraint logic instead of a small part of it. In this case we create a very simple model name constraint that return the name as pascal case.\n\nNote the difference here to [overwriting naming formatting](../overwrite-naming-formatting/) is that this removes all of the default constraints such as `no special chars`, etc. \n\nIf you do not handle these special cases you will encounter Modelina generate syntactically incorrect models when given certain inputs.\n\n",
        "displayName": "overwrite-default-constraint",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\nimport { pascalCase } from 'change-case';\n\nconst generator = new TypeScriptGenerator({\n  constraints: {\n    modelName: ({ modelName }) => {\n      return 'MyOwnCustomModelName';\n    }\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class MyOwnCustomModelName {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "overwrite-naming-formatting": {
        "description": "# Overwrite naming formatting\n\nThis example shows how to overwrite the naming formatter, and in this case, use constant case formatting instead of the default one.\n\n",
        "displayName": "overwrite-naming-formatting",
        "code": "import {\n  TypeScriptGenerator,\n  typeScriptDefaultModelNameConstraints\n} from '@asyncapi/modelina';\nimport { constantCase } from 'change-case';\n\nconst generator = new TypeScriptGenerator({\n  constraints: {\n    modelName: typeScriptDefaultModelNameConstraints({\n      NAMING_FORMATTER: (name) => {\n        return constantCase(name);\n      }\n    })\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class ROOT {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "passing-interpreter-options": {
        "description": "# Passing interpreter options\n\nThis example shows how to pass interpreter options.\n\n",
        "displayName": "passing-interpreter-options",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\nimport { CommonModel } from '@asyncapi/modelina';\nimport {\n  InterpreterSchemaType,\n  Interpreter,\n  InterpreterOptions\n} from '@asyncapi/modelina';\nimport { isModelObject } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  processorOptions: {\n    interpreter: {\n      ignoreAdditionalProperties: true\n    }\n  }\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "python-generate-json-serializer-and-deserializer": {
        "description": "# Python models with JSON serializer and deserializer\n\nA basic example of how to generate models and which includes a way to serialize them into and from JSON.\n\n",
        "displayName": "python-generate-json-serializer-and-deserializer",
        "code": "import { PythonFileGenerator, PYTHON_JSON_SERIALIZER_PRESET } from '@asyncapi/modelina';\n\nconst generator = new PythonFileGenerator({\n  presets: [PYTHON_JSON_SERIALIZER_PRESET]\n});\n\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: true,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root: \n  def __init__(self, input):\n    if hasattr(input, 'email'):\n    \tself._email = input.email\n    if hasattr(input, 'additionalProperties'):\n    \tself._additionalProperties = input.additionalProperties\n\n  @property\n  def email(self):\n  \treturn self._email\n  @email.setter\n  def email(self, email):\n  \tself._email = email\n\n  @property\n  def additionalProperties(self):\n  \treturn self._additionalProperties\n  @additionalProperties.setter\n  def additionalProperties(self, additionalProperties):\n  \tself._additionalProperties = additionalProperties\n\n  def serializeToJson(self):\n    return json.dumps(self.__dict__, default=lambda o: o.__dict__, indent=2)\n\n  @staticmethod\n  def deserializeFromJson(json_string):\n    return Root(**json.loads(json_string))\n",
        "language": "python"
    },
    "rust-generate-crate": {
        "description": "# Rust Data Models\n\nA basic example of how to use Modelina and output a Rust crate.\n\n## Requirements\n\n- [Rust](https://rustup.rs/)\n\nRust is required to compile this example.\n\n",
        "displayName": "rust-generate-crate",
        "code": "import {\n  RustFileGenerator,\n  RustRenderCompleteModelOptions,\n  RUST_COMMON_PRESET,\n  defaultRustRenderCompleteModelOptions,\n  RustPackageFeatures\n} from '@asyncapi/modelina';\nimport * as path from 'path';\n\nconst doc = {\n  $id: '_address',\n  type: 'object',\n  properties: {\n    street_name: { type: 'string' },\n    city: { type: 'string', description: 'City description' },\n    state: { type: 'string' },\n    house_number: { type: 'number' },\n    marriage: {\n      type: 'boolean',\n      description: 'Status if marriage live in given house'\n    },\n    members: {\n      oneOf: [{ type: 'string' }, { type: 'number' }, { type: 'boolean' }]\n    },\n    tuple_type: {\n      type: 'array',\n      items: [{ type: 'string' }, { type: 'number' }],\n      additionalItems: false\n    },\n    array_type: {\n      type: 'array',\n      items: { type: 'string' },\n      additionalItems: false\n    },\n    enum_type: {\n      enum: ['Texas', 'Alabama', 'California'],\n      default: 'California'\n    }\n  },\n  required: ['street_name', 'city', 'state', 'house_number', 'array_type'],\n  additionalProperties: {\n    type: 'string'\n  }\n};\n\nexport async function generate(): Promise<void> {\n  // initialize the generator from a preset\n  const generator = new RustFileGenerator({\n    presets: [\n      {\n        preset: RUST_COMMON_PRESET,\n        options: {\n          implementNew: true,\n          implementDefault: true\n        }\n      }\n    ]\n  });\n  // Generated files will be written to output/ directory\n  const outDir = path.join(__dirname, 'output');\n\n  // Run the file generator with options\n  const models = await generator.generateToPackage(doc, outDir, {\n    ...defaultRustRenderCompleteModelOptions,\n    supportFiles: true, // generate Cargo.toml and lib.rs\n    package: {\n      packageName: 'asyncapi-rs-example',\n      packageVersion: '1.0.0',\n      // set authors, homepage, repository, and license\n      authors: ['AsyncAPI Rust Champions'],\n      homepage: 'https://www.asyncapi.com/tools/modelina',\n      repository: 'https://github.com/asyncapi/modelina',\n      license: 'Apache-2.0',\n      description: 'Rust models generated by AsyncAPI Modelina',\n      // support 2018 editions and up\n      edition: '2018',\n      // enable serde_json\n      packageFeatures: [RustPackageFeatures.json] as RustPackageFeatures[]\n    }\n  } as RustRenderCompleteModelOptions);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "// Address represents a Address model.\n#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]\npub struct Address {\n    #[serde(rename=\"street_name\")]\n    pub street_name: String,\n    #[serde(rename=\"city\")]\n    pub city: String,\n    #[serde(rename=\"state\")]\n    pub state: String,\n    #[serde(rename=\"house_number\")]\n    pub house_number: f64,\n    #[serde(rename=\"marriage\", skip_serializing_if = \"Option::is_none\")]\n    pub marriage: Option<bool>,\n    #[serde(rename=\"members\", skip_serializing_if = \"Option::is_none\")]\n    pub members: Option<Box<crate::Members>>,\n    #[serde(rename=\"tuple_type\", skip_serializing_if = \"Option::is_none\")]\n    pub tuple_type: Option<Box<crate::TupleType>>,\n    #[serde(rename=\"array_type\")]\n    pub array_type: Vec<String>,\n    #[serde(rename=\"enum_type\", skip_serializing_if = \"Option::is_none\")]\n    pub enum_type: Option<Box<crate::EnumType>>,\n    #[serde(rename=\"additionalProperties\", skip_serializing_if = \"Option::is_none\")]\n    pub additional_properties: Option<std::collections::HashMap<String, String>>,\n}\n\nimpl Address {\n    pub fn new(street_name: String, city: String, state: String, house_number: f64, marriage: Option<bool>, members: Option<crate::Members>, tuple_type: Option<crate::TupleType>, array_type: Vec<String>, enum_type: Option<crate::EnumType>, additional_properties: Option<std::collections::HashMap<String, String>>) -> Address {\n        Address {\n            street_name,\n            city,\n            state,\n            house_number,\n            marriage,\n            members: members.map(Box::new),\n            tuple_type: tuple_type.map(Box::new),\n            array_type,\n            enum_type: enum_type.map(Box::new),\n            additional_properties,\n        }\n    }\n}\n\n\n// Members represents a union of types: String, f64, bool\n#[derive(Clone, Debug, Deserialize, PartialEq, PartialOrd, Serialize)]\n#[serde(untagged)]\npub enum Members {\n    #[serde(rename=\"MembersOneOf0\")]\n    MembersOneOf0(String),\n    #[serde(rename=\"MembersOneOf1\")]\n    MembersOneOf1(f64),\n    #[serde(rename=\"MembersOneOf2\")]\n    MembersOneOf2(bool),\n}\n\n\n\n// TupleType represents a TupleType model.\n#[derive(Clone, Debug, Deserialize, PartialEq, PartialOrd, Serialize)]\npub struct TupleType(String, f64);\n\nimpl TupleType {\n    pub fn new(value_0: String, value_1: f64) -> TupleType {\n        TupleType(value_0, value_1)\n    }\n}\n\n",
        "language": "rust"
    },
    "swagger2.0-from-object": {
        "description": "# Swagger 2.0 from object\n\nA basic example of how to use Modelina with a basic Swagger 2.0 object.\n\n",
        "displayName": "swagger2.0-from-object",
        "code": "import { OpenAPIV2 } from 'openapi-types';\nimport { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator();\nconst swaggerDocument = {\n  swagger: '2.0',\n  info: {\n    version: '0.1',\n    title: 'Simple basic api'\n  },\n  paths: {\n    '/test': {\n      post: {\n        parameters: [\n          {\n            in: 'body',\n            schema: {\n              $schema: 'http://json-schema.org/draft-07/schema#',\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                email: {\n                  type: 'string',\n                  format: 'email'\n                }\n              }\n            }\n          }\n        ],\n        responses: {\n          200: {\n            description: 'successful operation',\n            schema: {\n              $schema: 'http://json-schema.org/draft-07/schema#',\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                email: {\n                  type: 'string',\n                  format: 'email'\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(swaggerDocument);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\n\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class TestPost_200 {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}\n\nclass TestPostBody {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}",
        "language": "typescript"
    },
    "typescript-enum-type": {
        "description": "# TypeScript Enum Types\n\nA basic example of how to use Modelina can output different types of enums in TypeScript.\n\n",
        "displayName": "typescript-enum-type",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generatorEnum = new TypeScriptGenerator({ enumType: 'enum' });\nconst generatorUnion = new TypeScriptGenerator({ enumType: 'union' });\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    eventType: {\n      type: 'string',\n      enum: ['ping', 'pong']\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  console.log('Generator output with Union:');\n  const modelsUnion = await generatorUnion.generate(jsonSchemaDraft7);\n  for (const model of modelsUnion) {\n    console.log(model.result);\n  }\n\n  console.log('Generator output with Enum:');\n  const modelsEnum = await generatorEnum.generate(jsonSchemaDraft7);\n  for (const model of modelsEnum) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "output with Union:\nclass Root {\n  private _eventType?: EventType;\n\n  constructor(input: {\n    eventType?: EventType,\n  }) {\n    this._eventType = input.eventType;\n  }\n\n  get eventType(): EventType | undefined { return this._eventType; }\n  set eventType(eventType: EventType | undefined) { this._eventType = eventType; }\n}\ntype EventType = \"ping\" | \"pong\";\nGenerator output with Enum:\nclass Root {\n  private _eventType?: EventType;\n\n  constructor(input: {\n    eventType?: EventType,\n  }) {\n    this._eventType = input.eventType;\n  }\n\n  get eventType(): EventType | undefined { return this._eventType; }\n  set eventType(eventType: EventType | undefined) { this._eventType = eventType; }\n}\nenum EventType {\n  PING = \"ping\",\n  PONG = \"pong\"",
        "language": "typescript"
    },
    "typescript-generate-comments": {
        "description": "# TypeScript Data Models with comment generation functionality\n\nA basic example of how to generate comments from descriptions with the TypeScript generator.\n\n",
        "displayName": "typescript-generate-comments",
        "code": "import { TS_DESCRIPTION_PRESET, TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  modelType: 'interface',\n  presets: [TS_DESCRIPTION_PRESET]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'Test',\n  type: 'object',\n  additionalProperties: true,\n  required: ['string prop'],\n  description: 'Main Description',\n  properties: {\n    'string prop': { type: 'string' },\n    numberProp: {\n      type: 'number',\n      description: 'Description',\n      examples: 'Example'\n    },\n    objectProp: {\n      type: 'object',\n      $id: 'NestedTest',\n      properties: { stringProp: { type: 'string' } },\n      examples: ['Example 1', 'Example 2']\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "rray [\n    \"/**\n * Main Description\n */\ninterface Test {\n  stringProp: string;\n  /**\n   * Description\n   * @example Example\n   */\n  numberProp?: number;\n  /**\n   * @example Example 1, Example 2\n   */\n  objectProp?: NestedTest;\n  additionalProperties?: Map<string, any>;\n}\",\n  ],\n  Array [\n    \"/**\n * @example Example 1, Example 2\n */\ninterface NestedTest {\n  stringProp?: string;\n  additionalProperties?: Map<string, any>;\n}\",\n  ",
        "language": "typescript"
    },
    "typescript-generate-example": {
        "description": "# TypeScript Data Models with example function\n\nA basic example of how to use Modelina and output a TypeScript class with an example function.\n\n",
        "displayName": "typescript-generate-example",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\nimport { TS_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  presets: [\n    {\n      preset: TS_COMMON_PRESET,\n      options: {\n        example: true\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Root {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n\n  public static example(): Root {\n    const instance = new Root({} as any);\n    instance.email = \"string\";\n    return instance;\n  }\n}",
        "language": "typescript"
    },
    "typescript-generate-jsonbinpack": {
        "description": "# TypeScript data models with jsonbinpack support\n\nA basic example of how to generate models with [jsonbinpack](https://github.com/sourcemeta/jsonbinpack) support.\n\n",
        "displayName": "typescript-generate-jsonbinpack",
        "code": "import {\n  TS_JSONBINPACK_PRESET,\n  TypeScriptGenerator,\n  TS_COMMON_PRESET\n} from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  presets: [\n    {\n      preset: TS_COMMON_PRESET,\n      options: {\n        marshalling: true\n      }\n    },\n    TS_JSONBINPACK_PRESET\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'Test',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Test {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n\n  public marshal() : string {\n    let json = '{'\n    if(this.email !== undefined) {\n      json += `\"email\": ${typeof this.email === 'number' || typeof this.email === 'boolean' ? this.email : JSON.stringify(this.email)},`; \n    }\n\n\n    //Remove potential last comma \n    return `${json.charAt(json.length-1) === ',' ? json.slice(0, json.length-1) : json}}`;\n  }\n\n  public static unmarshal(json: string | object): Test {\n    const obj = typeof json === \"object\" ? json : JSON.parse(json);\n    const instance = new Test({} as any);\n\n    if (obj[\"email\"] !== undefined) {\n      instance.email = obj[\"email\"];\n    }\n\n\n\n    return instance;\n  }\n\n  public async jsonbinSerialize(): Promise<Buffer>{\n    const jsonData = JSON.parse(this.marshal());\n    const jsonbinpackEncodedSchema = await jsonbinpack.compileSchema({\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"$id\":\"Test\",\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"email\":{\"type\":\"string\",\"format\":\"email\",\"x-modelgen-inferred-name\":\"email\"}},\"x-modelgen-inferred-name\":\"root\"});\n    return jsonbinpack.serialize(jsonbinpackEncodedSchema, jsonData);\n  }\n\n  public static async jsonbinDeserialize(buffer: Buffer): Promise<Test> {\n    const jsonbinpackEncodedSchema = await jsonbinpack.compileSchema({\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"$id\":\"Test\",\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"email\":{\"type\":\"string\",\"format\":\"email\",\"x-modelgen-inferred-name\":\"email\"}},\"x-modelgen-inferred-name\":\"root\"});\n    const json = jsonbinpack.deserialize(jsonbinpackEncodedSchema, buffer);\n    return Test.unmarshal(json);\n  }\n}",
        "language": "typescript"
    },
    "typescript-generate-marshalling": {
        "description": "# TypeScript Data Models with un/marshalling functionality\n\nA basic example of how to use the un/marshalling functionality of the typescript class.\n\n",
        "displayName": "typescript-generate-marshalling",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\nimport { TS_COMMON_PRESET } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  presets: [\n    {\n      preset: TS_COMMON_PRESET,\n      options: {\n        marshalling: true\n      }\n    }\n  ]\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  $id: 'Test',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "class Test {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n\n  public marshal() : string {\n    let json = '{'\n    if(this.email !== undefined) {\n      json += `\"email\": ${typeof this.email === 'number' || typeof this.email === 'boolean' ? this.email : JSON.stringify(this.email)},`; \n    }\n\n\n    //Remove potential last comma \n    return `${json.charAt(json.length-1) === ',' ? json.slice(0, json.length-1) : json}}`;\n  }\n\n  public static unmarshal(json: string | object): Test {\n    const obj = typeof json === \"object\" ? json : JSON.parse(json);\n    const instance = new Test({} as any);\n\n    if (obj[\"email\"] !== undefined) {\n      instance.email = obj[\"email\"];\n    }\n\n\n\n    return instance;\n  }\n}",
        "language": "typescript"
    },
    "typescript-interface": {
        "description": "# TypeScript interface\n\nA basic example of how to use Modelina and output a TypeScript interface.\n\n",
        "displayName": "typescript-interface",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({ modelType: 'interface' });\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email'\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generate(jsonSchemaDraft7);\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "interface Root {\n  email?: string;\n}",
        "language": "typescript"
    },
    "typescript-use-cjs": {
        "description": "# TypeScript models use CJS module system\n\nThis example shows how you can generate the models to use CJS module system.\n\n",
        "displayName": "typescript-use-cjs",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  moduleSystem: 'CJS'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    person: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        email: {\n          type: 'string',\n          format: 'email'\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generateCompleteModels(jsonSchemaDraft7, {});\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\nclass Person {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}\nmodule.exports = Person;",
        "language": "typescript"
    },
    "typescript-use-esm": {
        "description": "# TypeScript models use ESM module system\n\nThis example shows how you can generate the models to use ESM module system.\n\n",
        "displayName": "typescript-use-esm",
        "code": "import { TypeScriptGenerator } from '@asyncapi/modelina';\n\nconst generator = new TypeScriptGenerator({\n  moduleSystem: 'ESM'\n});\nconst jsonSchemaDraft7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    person: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        email: {\n          type: 'string',\n          format: 'email'\n        }\n      }\n    }\n  }\n};\n\nexport async function generate(): Promise<void> {\n  const models = await generator.generateCompleteModels(jsonSchemaDraft7, {});\n  for (const model of models) {\n    console.log(model.result);\n  }\n}\nif (require.main === module) {\n  generate();\n}\n",
        "output": "\nclass Person {\n  private _email?: string;\n\n  constructor(input: {\n    email?: string,\n  }) {\n    this._email = input.email;\n  }\n\n  get email(): string | undefined { return this._email; }\n  set email(email: string | undefined) { this._email = email; }\n}\nexport default Person;\n",
        "language": "typescript"
    }
}