// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Should be able to render Rust Models and should log expected output to console 1`] = `
Array [
  "// Address represents a Address model.
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct Address {
    #[serde(rename=\\"street_name\\")]
    street_name: String,
    #[serde(rename=\\"city\\")]
    city: String,
    #[serde(rename=\\"state\\")]
    state: String,
    #[serde(rename=\\"house_number\\")]
    house_number: f64,
    #[serde(rename=\\"marriage\\", skip_serializing_if = \\"Option::is_none\\")]
    marriage: Option<bool>,
    #[serde(rename=\\"members\\", skip_serializing_if = \\"Option::is_none\\")]
    members: Option<Box<Members>>,
    #[serde(rename=\\"tuple_type\\", skip_serializing_if = \\"Option::is_none\\")]
    tuple_type: Option<Box<TupleType>>,
    #[serde(rename=\\"array_type\\")]
    array_type: Vec<String>,
    #[serde(rename=\\"enum_type\\", skip_serializing_if = \\"Option::is_none\\")]
    enum_type: Option<Box<EnumType>>,
    #[serde(rename=\\"additionalProperties\\", skip_serializing_if = \\"Option::is_none\\")]
    additional_properties: Option<std::collections::HashMap<String, String>>,
}

impl Address {
    pub fn new(street_name: String, city: String, state: String, house_number: f64, marriage: Option<bool>, members: Option<Members>, tuple_type: Option<TupleType>, array_type: Vec<String>, enum_type: Option<EnumType>, additional_properties: Option<std::collections::HashMap<String, String>>) -> Address {
        Address {
        street_name,
        city,
        state,
        house_number,
        marriage,
        members: members.map(Box::new),
        tuple_type: tuple_type.map(Box::new),
        array_type,
        enum_type: enum_type.map(Box::new),
        additional_properties,
        }
    }
}
",
]
`;

exports[`Should be able to render Rust Models and should log expected output to console 2`] = `
Array [
  "// Members represents a union of types: String, f64, bool
#[derive(Clone, Debug, Deserialize, PartialEq, PartialOrd, Serialize)]
pub enum Members {
    #[serde(rename=\\"Members0\\")]
    Members0(String),
    #[serde(rename=\\"Members1\\")]
    Members1(f64),
    #[serde(rename=\\"Members2\\")]
    Members2(bool),
}

",
]
`;

exports[`Should be able to render Rust Models and should log expected output to console 3`] = `
Array [
  "// TupleType represents a TupleType model.
#[derive(Clone, Debug, Deserialize, PartialEq, PartialOrd, Serialize)]
pub struct TupleType(String, f64);

impl TupleType {
    pub fn new(value_0: String, value_1: f64) -> TupleType {
        TupleType(value_0, value_1)
    }
}

",
]
`;

exports[`Should be able to render Rust Models and should log expected output to console 4`] = `
Array [
  "[package]
name = \\"asyncapi-rs-example\\"
version = \\"1.0.0\\"
authors = [\\"AsyncAPI Rust Champions\\"]
homepage = \\"https://www.asyncapi.com/tools/modelina\\"
repository = \\"https://github.com/asyncapi/modelina\\"
license = \\"Apache-2.0\\"
description = \\"Rust models generated by AsyncAPI Modelina\\"
edition = \\"2018\\"

[dependencies]
serde = { version = \\"1\\", features = [\\"derive\\"] }
serde_json = { version=\\"1\\", optional = true }

[dev-dependencies]

[features]
default = [\\"json\\"]
json = [\\"dep:serde_json\\"]",
]
`;

exports[`Should be able to render Rust Models and should log expected output to console 5`] = `
Array [
  "#[macro_use]
extern crate serde;
extern crate serde_json;

pub mod address;
pub use self::address::*;

pub mod members;
pub use self::members::*;

pub mod tuple_type;
pub use self::tuple_type::*;

pub mod enum_type;
pub use self::enum_type::*;",
]
`;

exports[`Should be able to render Rust Models and should log expected output to console 6`] = `undefined`;
