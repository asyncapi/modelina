 
const {writeFile, readFile} = require('node:fs').promises;

// Define the paths to the README and usage files
const README_PATH = './scripts/README.md'; // File path for the generated README file
const USAGE_PATH = './docs/usage.md'; // File path for the usage documentation file

const header = `---
title: 'Usage'
weight: 40
---

<!-- 

This file is automatically generated from updateUsageDocs.js script. In package.json in line 158-161 lines the following steps has been executed in order to run this script successfully - 

* generate:readme:create: It creates the initial content for the README file by printing the usage and commands tags using printf and redirects the output to scripts/README.md file.
* generate:readme:commands: It changes the directory to the scripts folder and executes the oclif readme command. This command generates the usage and commands sections based on the CLI commands and updates the content in the scripts/README.md file.
* generate:assets: This script combines the two previously mentioned scripts (generate:readme:toc and generate:commands) to generate the necessary assets, such as the README file and usage documentation.
* generate:commands: This script executes the following steps:
 - Runs the generate:readme:create script to create the initial content for the README file.
 - Executes the generate:readme:commands script to generate the usage and commands sections based on the CLI commands.
 - Runs the updateUsageDocs.js script using Node.js to update the usage documentation file with the contents of the generated README file.
 - Deletes the scripts/README.md file using the rimraf command.

-->

The Modelina CLI makes it easier to generate AsyncAPI Models.
`;

// Define an async function to write the header and the README contents to the usage documentation file
async function run() {
  try {
    await writeFile(USAGE_PATH, header);
    const readmeContents = await readContents();
    // Append the contents of the README file to the usage documentation file
    await writeFile(USAGE_PATH, readmeContents, { flag: 'a' });
  } catch (error) {
    console.error(error);
  }
}

run();

async function readContents() {
  let readmeContents;
  let commandsContent = '';

  while (commandsContent.length === 0) {
    readmeContents = await readFile(README_PATH, 'utf8');
    
    // Check if the content between <!-- commands --> and <!-- commandsstop --> is empty
    const commandsStartText = '<!-- commands -->';
    const commandStartIndex = readmeContents.indexOf(commandsStartText);
    const commandStopIndex = readmeContents.indexOf('<!-- commandsstop -->');
    // cutting the content between the above mentioned tags, removing white spaces and checking if there is some text as it will mean text was added by oclif
    commandsContent = readmeContents.slice(commandStartIndex + commandsStartText.length, commandStopIndex).trim();

    if (commandsContent.length === 0) {
      console.log('No content between <!-- commands --> and <!-- commandsstop -->. Trying again...');
    } else {
      console.log('Content found!');
    }

    await delay(3000); // 3-second delay
  }

  return readmeContents;
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
