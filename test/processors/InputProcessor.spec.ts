import * as fs from 'fs';
import * as path from 'path';
import {parse} from '@asyncapi/parser';
import { InputProcessor } from '../../src/processors/InputProcessor';

describe('InputProcessor', function() {
    /**
     * The input schema when processed should be equals to the expected CommonInputModel
     * 
     * @param inputSchemaPath 
     * @param expectedCommonModulePath 
     */
    const expectFunction = async (inputSchemaPath: string, expectedCommonModulePath: string) => {
        const processor = new InputProcessor();
        const inputSchemaString = fs.readFileSync(path.resolve(__dirname, inputSchemaPath), 'utf8');
        const expectedCommonInputModelString = fs.readFileSync(path.resolve(__dirname, expectedCommonModulePath), 'utf8');
        const inputSchema = JSON.parse(inputSchemaString);
        const expectedCommonInputModel = JSON.parse(expectedCommonInputModelString);
        const commonInputModel = await processor.process(inputSchema);
        expect(commonInputModel).toEqual(expectedCommonInputModel);
    }
    describe('process()', function() {
        describe('should be able to process JSON schema input', function() {
            test('with absence types', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/absence_type.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/absence_type.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
            test('with conditional schemas', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/applying_conditional_schemas.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/applying_conditional_schemas.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
            test('with combination schemas', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/combination_schemas.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/combination_schemas.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
            test('with enum schemas', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/enum.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/enum.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
            test('with items schemas', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/items.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/items.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
            test('with multiple objects', async function() {
                const inputSchemaPath = './JsonSchemaInputProcessor/multiple_objects.json';
                const expectedCommonModulePath = './JsonSchemaInputProcessor/commonInputModel/multiple_objects.json';
                await expectFunction(inputSchemaPath, expectedCommonModulePath);
            });
        });

        describe('should be able to process AsyncAPI schema input', function() {
            test('with pure object', async function() {
                const processor = new InputProcessor();
                const basicDocString = fs.readFileSync(path.resolve(__dirname, './AsyncAPIInputProcessor/basic.json'), 'utf8');
                const expectedCommonInputModelString = fs.readFileSync(path.resolve(__dirname, './AsyncAPIInputProcessor/commonInputModel/basic.json'), 'utf8');
                const basicDoc = JSON.parse(basicDocString);
                const expectedCommonInputModel = JSON.parse(expectedCommonInputModelString);
                const commonInputModel = await processor.process(basicDoc);
                expect(commonInputModel).toMatchObject(expectedCommonInputModel);
            });
            test('with parsed document', async function() {
                const processor = new InputProcessor();
                const basicDocString = fs.readFileSync(path.resolve(__dirname, './AsyncAPIInputProcessor/basic.json'), 'utf8');
                const expectedCommonInputModelString = fs.readFileSync(path.resolve(__dirname, './AsyncAPIInputProcessor/commonInputModel/basic.json'), 'utf8');
                const expectedCommonInputModel = JSON.parse(expectedCommonInputModelString);
                const parsedObject = await parse(basicDocString);
                const commonInputModel = await processor.process(parsedObject);
                expect(commonInputModel).toMatchObject(expectedCommonInputModel);
            });
        });
    });
});